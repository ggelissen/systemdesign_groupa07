# -*- coding: utf-8 -*-
## WORK IN PROGRESS 
from csv import reader
import scipy as sp
from matplotlib import pyplot as plt
from scipy import integrate
import numpy as np

rho = 1.225
v = 258.9704
q = 0.5*rho*(v**2)

halfspan = 33.5
b = 67  # m
cr = 13.4
taper = 0.28
t_c = 0.113

E = 68.9 * 10**9
poisson = 0.33

Ww = 38229.5 / 2  # kg
Wf = (125407 + 522.9) / 2  # kg
Weng = 6033  # kg
grav = 9.81  # m/s^2
n = 2.5

CL0 = 0.04647
CL10 = 0.97586
CLD = 0.5785


""" shear distr. """
# Create arrays for the values in the CSV file
ylst0 = np.array([])
chordlst0 = np.array([])
Ailst0 = np.array([])
Cllst0 = np.array([])
ICdlst0 = np.array([])
Cmc4lst0 = np.array([])

ylst10 = np.array([])
chordlst10 = np.array([])
Ailst10 = np.array([])
Cllst10 = np.array([])
ICdlst10 = np.array([])
Cmc4lst10 = np.array([])

# Read the CSV file
data0 = []
data10 = []
with open('A07csv0.csv', 'r') as file:
    csv_reader = reader(file)
    for row in csv_reader:
        data0.append(row)

with open('A07csv10.csv', 'r') as file2:
    csv_reader = reader(file2)
    for row in csv_reader:
        data10.append(row)

# Append correct values from csv_reader to arrays
for row in data0[51:81]:      # Range can be adjusted here!
    ylst0 = np.append(ylst0, float(row[0]))
    chordlst0 = np.append(chordlst0, float(row[1]))
    Ailst0 = np.append(Ailst0, float(row[2]))
    Cllst0 = np.append(Cllst0, float(row[3]))
    ICdlst0 = np.append(ICdlst0, float(row[5]))
    Cmc4lst0 = np.append(Cmc4lst0, float(row[7]))

for row in data10[51:81]:      # Range can be adjusted here!
    ylst10 = np.append(ylst10, float(row[0]))
    chordlst10 = np.append(chordlst10, float(row[1]))
    Ailst10 = np.append(Ailst10, float(row[2]))
    Cllst10 = np.append(Cllst10, float(row[3]))
    ICdlst10 = np.append(ICdlst10, float(row[5]))
    Cmc4lst10 = np.append(Cmc4lst10, float(row[7]))

# Functions to interpolate the values
def yCl(y, Cl):
    return sp.interpolate.interp1d(y,Cl,kind='cubic',fill_value="extrapolate")

def ychord(y, chord):
    return sp.interpolate.interp1d(y,chord,kind='cubic',fill_value="extrapolate")

def yICd(y, ICd):
    return sp.interpolate.interp1d(y,ICd,kind='cubic',fill_value="extrapolate")

def yCmc4(y, cmc4):
    return sp.interpolate.interp1d(y,cmc4,kind='cubic',fill_value="extrapolate")

# Define set of values for y
yvalues = np.arange(0, halfspan, 0.01)
yCl_result0 = yCl(ylst0, Cllst0)
ychord_result0 = ychord(ylst0, chordlst0)
yICd_result0 = yICd(ylst0, ICdlst0)
yCmc4_result0 = yCmc4(ylst0, Cmc4lst0)

yCl_result10 = yCl(ylst10, Cllst10)
ychord_result10 = ychord(ylst10, chordlst10)
yICd_result10 = yICd(ylst10, ICdlst10)
yCmc4_result10 = yCmc4(ylst10, Cmc4lst10)

# finding entry in list closest to val
def closest(lst, val):
    lst = np.asarray(lst)
    idx = (np.abs(lst - val)).argmin()

    return lst[idx]

# functions to define all loading distribution (ie decreasing triangular shape for dry, const for fuel)
engload = []
for element in yvalues:
    if element != closest(yvalues, (b / 2) * 0.35):
        engload.append(0)
    if element == closest(yvalues, (b / 2) * 0.35):
        engload.append(Weng * grav)
def cts_loaddistr(y):
    if y == 0:
        f = g = 0
    if y != 0:
        c = 4 * Ww * grav / b
        a = (-1 * (Ww * grav * 8)) / (b ** 2)
        f = a * y + c
    if y <= b / 4 and y > 0:
        g = Wf * grav / (b / 4)
    if y > b / 4:
        g = 0
    return f + g  #f is structural weight, g is fuel weight

# Angle of Attack
alpha_sin = (CLD-CL0)/(CL10-CL0) * np.sin(10*np.pi/180)
alpha = np.arcsin(alpha_sin)

# Functions to calculate distributed load an point load
def Ldistribution0(x):
    return yCl_result0(x) * q * ychord_result0(x)
liftdistributionlst0 = np.array([])

def Ldistribution10(x):
    return yCl_result10(x) * q * ychord_result10(x)
liftdistributionlst10 = np.array([])

def LdistributionD(x):
    return (Ldistribution0(x) + ((CLD - CL0)/(CL10 - CL0)) * (Ldistribution10(x) - Ldistribution0(x))) * np.cos(alpha)
liftdistributionlst = np.array([])
for element in yvalues:
    liftdistributionlst = np.append(liftdistributionlst, (LdistributionD(element)*n) - cts_loaddistr(element))

def sheardistribution(y):
    shear = integrate.cumtrapz(liftdistributionlst, y, initial=0)
    sheardistributionlst = np.flip(shear)
    return sheardistributionlst

shearlst = sheardistribution(yvalues)

""" web definition """
spanlocation = input("Enter the spanwise location: ")
hf = float(input("Enter the height of the front spar: "))
tf = float(input("Enter the thickness of the front spar: "))
hr = float(input("Enter the height of the rear spar: "))
tr = float(input("Enter the thickness of the rear spar: "))
hm = float(input("Enter the thickness of the mid spar: "))
tm = float(input("Enter the thickness of the mid spar: "))
nr = int(input("Enter the amount of ribs: "))

t = (1/3)*(tf + tr + tm)

def chord(y):
    return cr - cr*(1-taper)*(y/(b/2))


avgsheardist = shearlst/((hf * tf + hr * tr + hm * tm))

a = (b/2)/nr ## assuming equal spacing
kslst = [15, 13, 11.8, 11, 10.5, 9.8, 9.7, 9.6]
a_blst = [1, 1.2, 1.5, 1.7, 2, 2.5, 3, 3.5]

#def ks(ratio, ks_coeff):
 #   return sp.interpolate.interp1d(ratio, ks_coeff, kind = 'cubic', fill_value = 'extrapolate')

interpolation_function = sp.interpolate.interp1d(a_blst, kslst, kind = 'cubic', fill_value = 'extrapolate')
a_b_interp = np.linspace(1, 3.5, 251)
ks_interp = interpolation_function(a_b_interp)


avg_b = []
distr_ks = []
distr_tau_cr = []
bays = []

for nth in range(nr): ## dividing the calculations over the bays
    b1 = t_c*chord(nth*a) ## lefthandside, closest to root, evaluated at the nth bay
    b2 = t_c*chord((nth + 1)*a) ## closest to tip
    b = 0.5 * (b1 + b2)
    avg_b.append(b)
    print(b1, b2)
    
    ks = ks_interp[np.where(a_b_interp == (round(a/b, 2)))[0]]
    distr_ks.append(ks)
    print(np.where(a_b_interp == (round(a/b, 2))))
    print(ks)
    
    #tau_cr = ((float(ks)*E*np.pi()**2) / (12*(1-poisson**2))) * (t/b)**2
    #distr_tau_cr.append(tau_cr)
    
    bays.append(nth)

    
#plt.subplot(1,2,1)
#plt.plot(bays,distr_tau_cr)

"""
plt.subplot(1,2,1)
plt.plot(yvalues, sheardistribution(yvalues), "b")
plt.xlabel('Spanwise location [m]')
plt.ylabel('Shear [N]')
plt.title('Shear distribution')

plt.subplot(1,2,2)
plt.plot(yvalues, avgsheardist, "g")
plt.xlabel('Spanwise location [m]')
plt.ylabel('Average Shear')
plt.title('Average Shear Distribution')"""
#plt.show()
